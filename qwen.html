<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Scene with Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">Loading 3D Scene...</div>
    <!-- Import Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables for Three.js components
        let scene, camera, renderer, objects = [];
        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Initialize the application
        function init() {
            try {
                const loadingElement = document.getElementById('loading');
                loadingElement.style.display = 'block';

                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);

                // Camera setup with responsive field of view
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.z = 5;

                // Renderer setup with performance optimizations
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                // Enable pixel ratio limiting for better performance on high-DPI displays
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(renderer.domElement);

                // Add ambient light for basic illumination
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                // Add directional light for dynamic shadows
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 1, 1);
                scene.add(directionalLight);

                // Create three interactive objects
                // 1. Cube
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x4ecdc4 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.x = -2;
                cube.userData = { type: 'cube', isHovered: false };
                scene.add(cube);
                objects.push(cube);

                // 2. Sphere
                const sphereGeometry = new THREE.SphereGeometry(0.8, 32, 32);
                const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.x = 0;
                sphere.userData = { type: 'sphere', toggled: false };
                scene.add(sphere);
                objects.push(sphere);

                // 3. Torus
                const torusGeometry = new THREE.TorusGeometry(0.7, 0.25, 16, 64);
                const torusMaterial = new THREE.MeshStandardMaterial({ color: 0xffe66d });
                const torus = new THREE.Mesh(torusGeometry, torusMaterial);
                torus.position.x = 2;
                torus.userData = { type: 'torus', scaleUp: false };
                scene.add(torus);
                objects.push(torus);

                // Event listeners for mouse and touch interactions
                document.addEventListener('mousedown', onMouseDown, false);
                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mouseup', onMouseUp, false);
                document.addEventListener('touchstart', onTouchStart, false);
                document.addEventListener('touchmove', onTouchMove, false);
                document.addEventListener('touchend', onTouchEnd, false);
                window.addEventListener('resize', onWindowResize, false);

                loadingElement.style.display = 'none';
                animate();
            } catch (error) {
                console.error('Initialization failed:', error);
                document.getElementById('loading').textContent = 'Error loading 3D scene. Please refresh.';
            }
        }

        // Handle window resize for responsive design
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Mouse interaction handlers
        function onMouseDown(event) {
            event.preventDefault();
            isDragging = true;
            previousMousePosition = {
                x: event.clientX - windowHalfX,
                y: event.clientY - windowHalfY
            };
            checkInteraction(event.clientX, event.clientY);
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaMove = {
                    x: (event.clientX - windowHalfX) - previousMousePosition.x,
                    y: (event.clientY - windowHalfY) - previousMousePosition.y
                };
                targetRotation.y += deltaMove.x * 0.005;
                targetRotation.x += deltaMove.y * 0.005;
                previousMousePosition = {
                    x: event.clientX - windowHalfX,
                    y: event.clientY - windowHalfY
                };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        // Touch interaction handlers for mobile devices
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: event.touches[0].clientX - windowHalfX,
                    y: event.touches[0].clientY - windowHalfY
                };
                checkInteraction(event.touches[0].clientX, event.touches[0].clientY);
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (isDragging && event.touches.length === 1) {
                const deltaMove = {
                    x: (event.touches[0].clientX - windowHalfX) - previousMousePosition.x,
                    y: (event.touches[0].clientY - windowHalfY) - previousMousePosition.y
                };
                targetRotation.y += deltaMove.x * 0.005;
                targetRotation.x += deltaMove.y * 0.005;
                previousMousePosition = {
                    x: event.touches[0].clientX - windowHalfX,
                    y: event.touches[0].clientY - windowHalfY
                };
            }
        }

        function onTouchEnd() {
            isDragging = false;
        }

        // Check for object interaction
        function checkInteraction(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type === 'sphere') {
                    object.userData.toggled = !object.userData.toggled;
                    object.material.color.set(object.userData.toggled ? 0x5f27cd : 0xff6b6b);
                } else if (object.userData.type === 'torus') {
                    object.userData.scaleUp = true;
                }
            }
        }

        // Animation loop with performance optimizations
        function animate() {
            requestAnimationFrame(animate);

            // Update cube rotations with smooth damping
            targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));
            scene.rotation.x += (targetRotation.x - scene.rotation.x) * 0.1;
            scene.rotation.y += (targetRotation.y - scene.rotation.y) * 0.1;

            // Animate individual objects
            objects.forEach((object, index) => {
                if (object.userData.type === 'cube') {
                    object.rotation.x += 0.01 * (index + 1);
                    object.rotation.y += 0.005 * (index + 1);
                    object.material.emissive.set(object.userData.isHovered ? 0x00d9ff : 0x000000);
                } else if (object.userData.type === 'sphere') {
                    object.position.y = Math.sin(Date.now() * 0.001) * 0.45;
                } else if (object.userData.type === 'torus') {

              
