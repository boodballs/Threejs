<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Geometric Scene</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #4d88ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            user-select: none;
        }
        
        #fps {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
        }
        
        #object-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 5;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading 3D Scene...</p>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="ui">
        <h3>Geometric 3D Scene</h3>
        <p>Drag to rotate | Scroll to zoom | Click objects to interact</p>
    </div>
    
    <div id="fps">FPS: --</div>
    
    <div id="object-info">
        <h3 id="object-title">Object</h3>
        <p id="object-desc">Description here</p>
    </div>
    
    <!-- Load Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/examples/jsm/controls/OrbitControls.js"></script>
    
    <script>
        // Main application logic
        (function() {
            // Scene variables
            let scene, camera, renderer, controls;
            let objects = [];
            let lastTime = 0;
            let frameCount = 0;
            
            // DOM elements
            const container = document.getElementById('canvas-container');
            const loading = document.getElementById('loading');
            const fpsCounter = document.getElementById('fps');
            const objectInfo = document.getElementById('object-info');
            const objectTitle = document.getElementById('object-title');
            const objectDesc = document.getElementById('object-desc');
            
            // Object information data
            const objectData = {
                cube: {
                    title: "Rotating Cube",
                    description: "This cube rotates on multiple axes. Click to change its color!"
                },
                pyramid: {
                    title: "Colorful Pyramid",
                    description: "A tetrahedron with shimmering colors. Click to make it jump!"
                },
                sphere: {
                    title: "Pulsing Sphere",
                    description: "This sphere gently pulses. Click to change its pulse pattern!"
                }
            };
            
            // Interaction handler
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Check for mobile devices
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Initialize the scene
            function init() {
                // Create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a2e);
                
                // Set up camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.z = 10;
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                
                // Add orbit controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // Add lighting
                addLights();
                
                // Add objects
                createObjects();
                
                // Setup event listeners
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('mousedown', onMouseDown);
                window.addEventListener('touchstart', onTouchStart, { passive: false });
                
                // Hide loading screen and start animation
                setTimeout(() => {
                    loading.classList.add('hidden');
                    animate();
                }, 500);
            }
            
            // Add lights to the scene
            function addLights() {
                // Ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                // Main directional light
                const mainLight = new THREE.DirectionalLight(0xffffff, 1);
                mainLight.position.set(10, 10, 10);
                scene.add(mainLight);
                
                // Accent light from opposite direction
                const accentLight = new THREE.DirectionalLight(0x0088ff, 0.5);
                accentLight.position.set(-5, -2, -5);
                scene.add(accentLight);
            }
            
            // Create interactive 3D objects
            function createObjects() {
                // 1. Create a cube
                const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
                const cubeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4d88ff,
                    shininess: 30
                });
                
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(-3, 0, 0);
                cube.userData = {
                    type: 'cube',
                    rotationSpeed: { x: 0.01, y: 0.02 },
                    colors: [0x4d88ff, 0xff4d4d, 0x4dff88, 0xffdd4d],
                    currentColorIndex: 0
                };
                scene.add(cube);
                objects.push(cube);
                
                // 2. Create a pyramid (tetrahedron)
                const pyramidGeometry = new THREE.TetrahedronGeometry(1.5);
                const pyramidMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff4d4d,
                    shininess: 50,
                    specular: 0xffffff
                });
                
                const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
                pyramid.position.set(3, 0, 0);
                pyramid.userData = {
                    type: 'pyramid',
                    rotationSpeed: { x: 0.005, y: 0.01, z: 0.008 },
                    jumping: false,
                    jumpHeight: 1.5,
                    jumpSpeed: 0.05,
                    jumpProgress: 0,
                    originalY: 0
                };
                scene.add(pyramid);
                objects.push(pyramid);
                
                // 3. Create a sphere
                const sphereGeometry = new THREE.SphereGeometry(1.2, 32, 32);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4dff88,
                    shininess: 60,
                    specular: 0x888888
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(0, 2.5, 0);
                sphere.userData = {
                    type: 'sphere',
                    pulseSpeed: 0.03,
                    pulseAmount: 0.2,
                    pulseProgress: 0,
                    pulsePattern: 'sine',
                    patterns: ['sine', 'bounce', 'sharp']
                };
                scene.add(sphere);
                objects.push(sphere);
            }
            
            // Handle window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Handle mouse clicks
            function onMouseDown(event) {
                // Calculate mouse position in normalized device coordinates (-1 to +1)
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                checkObjectInteraction();
            }
            
            // Handle touch events
            function onTouchStart(event) {
                event.preventDefault();
                
                if (event.touches.length > 0) {
                    // Use the first touch point
                    mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                    
                    checkObjectInteraction();
                }
            }
            
            // Check if an object was clicked/touched
            function checkObjectInteraction() {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(objects);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    
                    // Handle object-specific interactions
                    if (object.userData.type === 'cube') {
                        // Change cube color
                        object.userData.currentColorIndex = 
                            (object.userData.currentColorIndex + 1) % object.userData.colors.length;
                        object.material.color.setHex(
                            object.userData.colors[object.userData.currentColorIndex]
                        );
                        
                        showObjectInfo('cube');
                    } 
                    else if (object.userData.type === 'pyramid') {
                        // Make pyramid jump
                        if (!object.userData.jumping) {
                            object.userData.jumping = true;
                            object.userData.jumpProgress = 0;
                            object.userData.originalY = object.position.y;
                        }
                        
                        showObjectInfo('pyramid');
                    } 
                    else if (object.userData.type === 'sphere') {
                        // Change pulse pattern
                        const patterns = object.userData.patterns;
                        const currentIndex = patterns.indexOf(object.userData.pulsePattern);
                        const nextIndex = (currentIndex + 1) % patterns.length;
                        object.userData.pulsePattern = patterns[nextIndex];
                        
                        showObjectInfo('sphere');
                    }
                } else {
                    hideObjectInfo();
                }
            }
            
            // Show object information panel
            function showObjectInfo(type) {
                objectTitle.textContent = objectData[type].title;
                objectDesc.textContent = objectData[type].description;
                objectInfo.style.opacity = '1';
                
                // Auto-hide after 3 seconds
                setTimeout(hideObjectInfo, 3000);
            }
            
            // Hide object information panel
            function hideObjectInfo() {
                objectInfo.style.opacity = '0';
            }
            
            // Update FPS counter
            function updateFPS() {
                if (frameCount % 10 !== 0) return;
                
                const now = performance.now();
                const delta = now - lastTime;
                lastTime = now;
                
                const fps = Math.round(10000 / delta);
                fpsCounter.textContent = `FPS: ${fps}`;
            }
            
            // Update object animations
            function updateObjects(deltaTime) {
                objects.forEach(object => {
                    // Common rotation for all objects
                    if (object.userData.rotationSpeed) {
                        object.rotation.x += object.userData.rotationSpeed.x;
                        object.rotation.y += object.userData.rotationSpeed.y;
                        if (object.userData.rotationSpeed.z) {
                            object.rotation.z += object.userData.rotationSpeed.z;
                        }
                    }
                    
                    // Object-specific animations
                    if (object.userData.type === 'pyramid' && object.userData.jumping) {
                        // Handle jumping animation
                        object.userData.jumpProgress += object.userData.jumpSpeed;
                        
                        if (object.userData.jumpProgress <= 1) {
                            // Jump up and down using sine curve
                            const jumpHeight = object.userData.jumpHeight * 
                                Math.sin(object.userData.jumpProgress * Math.PI);
                            
                            object.position.y = object.userData.originalY + jumpHeight;
                        } else {
                            // Reset jump when complete
                            object.position.y = object.userData.originalY;
                            object.userData.jumping = false;
                        }
                    }
                    
                    if (object.userData.type === 'sphere') {
                        // Handle pulsing animation based on selected pattern
                        object.userData.pulseProgress += object.userData.pulseSpeed;
                        
                        // Reset progress when complete cycle
                        if (object.userData.pulseProgress > Math.PI * 2) {
                            object.userData.pulseProgress = 0;
                        }
                        
                        let scale = 1;
                        
                        switch (object.userData.pulsePattern) {
                            case 'sine':
                                // Smooth sine wave pulsing
                                scale = 1 + Math.sin(object.userData.pulseProgress) * 
                                    object.userData.pulseAmount;
                                break;
                                
                            case 'bounce':
                                // Bounce effect (absolute value of sine)
                                scale = 1 + Math.abs(Math.sin(object.userData.pulseProgress)) * 
                                    object.userData.pulseAmount;
                                break;
                                
                            case 'sharp':
                                // Sharp triangular pulse
                                const triangleWave = 2 * Math.abs(
                                    (object.userData.pulseProgress / Math.PI) % 2 - 1
                                ) - 1;
                                scale = 1 + triangleWave * object.userData.pulseAmount;
                                break;
                        }
                        
                        object.scale.set(scale, scale, scale);
                    }
                });
            }
            
            // Animation loop
            function animate(time) {
                requestAnimationFrame(animate);
                frameCount++;
                
                // Calculate time delta for smooth animations
                const deltaTime = time - lastTime;
                
                // Update controls
                controls.update();
                
                // Update FPS counter
                updateFPS();
                
                // Update object animations
                updateObjects(deltaTime);
                
                // Render scene
                renderer.render(scene, camera);
            }
            
            // Start everything
            try {
                init();
            } catch (error) {
                console.error("Error initializing:", error);
                loading.innerHTML = `
                    <h2>Error</h2>
                    <p>Could not initialize 3D scene:</p>
                    <p>${error.message}</p>
                    <p>Please try a different browser.</p>
                `;
            }
        })();
    </script>
</body>
</html>
