<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Added user-scalable=no for better mobile experience -->
    <title>Interactive Animated 3D Cube - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; } /* Remove margin, hide scrollbars, set background */
        canvas { display: block; } /* Prevent potential spacing issues */
        #info { /* Basic info text styling */
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100; /* Ensure it's above the canvas */
        }
    </style>
</head>
<body>

    <div id="info">Drag to rotate, Scroll/Pinch to zoom, Right-Click/Two-Finger drag to pan</div>

    <!-- Import Three.js core and OrbitControls -->
    <!-- Using unpkg CDN. Ensure you have an internet connection. -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <!-- Your Three.js application code -->
    <script type="module">
        // Import necessary components
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Import OrbitControls

        // Declare variables accessible in multiple functions
        let scene, camera, renderer, cube, controls;

        // Initialization function
        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2a); // Slightly different dark background

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 5); // Position camera slightly higher and back

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI displays
            document.body.appendChild(renderer.domElement);

            // 4. Geometry (Cube)
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);

            // 5. Material (More interesting)
            // Using MeshPhongMaterial for distinct highlights
            const material = new THREE.MeshPhongMaterial({
                color: 0x44aaff,    // A bright blue
                shininess: 100,     // How shiny the highlight is
                specular: 0xaaaaaa // Color of the highlight
            });

            // 6. Mesh (Cube)
            cube = new THREE.Mesh(geometry, material);
            cube.position.y = 0.5; // Lift the cube slightly so it's not centered at the origin
            scene.add(cube);

            // Add a simple ground plane
            const planeGeometry = new THREE.PlaneGeometry(10, 10);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
            plane.position.y = -0.75; // Position it below the cube's bottom face
            scene.add(plane);


            // 7. Lighting
            // Ambient Light
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0); // Soft white light
            scene.add(ambientLight);

            // Directional Light (for highlights and shadows)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Point Light (adds more dynamic lighting)
            const pointLight = new THREE.PointLight(0xffaa00, 1, 10); // Orange-ish light
            pointLight.position.set(-5, 3, -3);
            scene.add(pointLight);
            // Optional: Add a helper to visualize the point light
            // const pointLightHelper = new THREE.PointLightHelper(pointLight, 0.5);
            // scene.add(pointLightHelper);


            // 8. Controls (OrbitControls)
            // Pass the camera and the renderer's DOM element
            controls = new OrbitControls(camera, renderer.domElement);

            // Configuration for smoother interaction
            controls.enableDamping = true; // An animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // If true, panning orthogonal to camera direction; if false, panning parallel to ground plane
            controls.minDistance = 2; // Minimum zoom distance
            controls.maxDistance = 15; // Maximum zoom distance
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent camera going below the ground slightly
            controls.target.set(0, 0.5, 0); // Set the point the camera orbits around (the cube's position)
            controls.update(); // Must be called after any manual changes to the camera's transform or controls' target

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        // Function to handle window resize events
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Update pixel ratio on resize too
        }

        // Animation loop function
        function animate(time) { // time parameter provided by requestAnimationFrame
            // Request the next frame
            requestAnimationFrame(animate);

            // --- Animation ---
            // Subtle cube rotation (optional, can be nice)
            const speed = 0.0005;
            cube.rotation.x = time * speed;
            cube.rotation.y = time * speed * 1.5; // Rotate slightly faster on Y

            // --- Update Controls ---
            // Required if controls.enableDamping or controls.autoRotate are set to true
            controls.update();

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Start the application ---
        init();
        animate();
        // --- End Start ---

    </script>
</body>
</html>
