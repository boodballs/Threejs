<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Luigi Electric Kick!</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #050a1a; /* Dark blue background, fitting the stadium night */
      color: white; /* For any potential text overlays */
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display:block;
      color: #aaffff;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="info">Drag to rotate</div>

  <!-- Three.js & OrbitControls via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.min.js"></script>

  <script>
    let scene, camera, renderer, controls, imagePlane, particles = [];

    // Use TextureLoader for the image
    const loader = new THREE.TextureLoader();
    // Relative path for deployment (ensure electric.jpg is in the same folder as this HTML)
    const imageURL = './electric.jpg';

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      // Camera setup
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 4; // Adjusted distance to better frame the image

      // Renderer setup
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // OrbitControls setup
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // Smooths out the rotation
      controls.dampingFactor = 0.05;
      controls.autoRotate = true; // Adds a gentle automatic rotation
      controls.autoRotateSpeed = 0.7;
      controls.minDistance = 2; // Prevent zooming too close
      controls.maxDistance = 10; // Prevent zooming too far out

      // Lighting
      // Ambient light to softly illuminate the scene
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      // Directional light to give some highlights, simulating stadium lights
      const directionalLight = new THREE.DirectionalLight(0xaaffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Load the texture and create the image plane
      loader.load(imageURL, function(texture) {
        // Calculate aspect ratio to display the image correctly
        const imageAspect = texture.image.height / texture.image.width;
        const planeWidth = 3; // Base width for the image plane
        const planeHeight = planeWidth * imageAspect;

        const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        // Use MeshBasicMaterial so the image isn't affected strongly by scene lights
        const planeMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide, // Render both sides
            transparent: true // Allows potential transparency in image
         });
        imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        scene.add(imagePlane);
      },
      undefined, // onProgress callback (optional)
      function (err) {
          console.error('An error happened loading the texture:', err);
          // Display error message if image fails to load
          const errorDiv = document.createElement('div');
          errorDiv.style.position = 'absolute';
          errorDiv.style.top = '50%';
          errorDiv.style.left = '50%';
          errorDiv.style.transform = 'translate(-50%, -50%)';
          errorDiv.style.color = 'red';
          errorDiv.style.fontSize = '18px';
          errorDiv.innerText = 'Error: Could not load electric.jpg. Make sure it is in the same folder as index.html.';
          document.body.appendChild(errorDiv);
      });

      // Create electric particles
      const particleCount = 200;
      const particleGeometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const electricColors = [new THREE.Color(0x00ff00), new THREE.Color(0x00ffff), new THREE.Color(0xccffcc)]; // Green, Cyan, Light Green

      for (let i = 0; i < particleCount; i++) {
          // Position particles in a sphere around the center
          const radius = 2 + Math.random() * 2;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);

          positions.push(radius * Math.sin(phi) * Math.cos(theta)); // x
          positions.push(radius * Math.sin(phi) * Math.sin(theta)); // y
          positions.push(radius * Math.cos(phi));                   // z

          // Assign a random electric color
          const color = electricColors[Math.floor(Math.random() * electricColors.length)];
          colors.push(color.r, color.g, color.b);

          // Store initial angle and radius for animation
          particles.push({
              theta: theta,
              phi: phi,
              radius: radius,
              speed: (Math.random() - 0.5) * 0.02 // Random speed and direction
          });
      }

      particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const particleMaterial = new THREE.PointsMaterial({
          size: 0.05,
          vertexColors: true, // Use colors defined in geometry
          blending: THREE.AdditiveBlending, // Make particles glow
          transparent: true,
          sizeAttenuation: true // Make particles smaller further away
      });

      const points = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(points);

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update controls (needed for damping and auto-rotate)
      controls.update();

      // Animate particles - make them orbit/swirl
      const positions = scene.children.find(c => c instanceof THREE.Points)?.geometry.attributes.position;
      if (positions) {
          for (let i = 0; i < particles.length; i++) {
              const p = particles[i];
              p.theta += p.speed; // Update angle

              // Update position based on spherical coordinates
              const index = i * 3;
              positions.array[index] = p.radius * Math.sin(p.phi) * Math.cos(p.theta);
              positions.array[index + 1] = p.radius * Math.sin(p.phi) * Math.sin(p.theta);
              // positions.array[index + 2] stays the same (p.radius * Math.cos(p.phi)) unless you want vertical movement too
          }
          positions.needsUpdate = true; // Important: Tell Three.js the positions have changed
      }


      // Render the scene
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
