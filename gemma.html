<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex; /* Keep flex for centering */
            justify-content: center;
            align-items: center;
            color: white;
            font-family: sans-serif;
            z-index: 9999;
            transition: opacity 0.5s ease-out; /* Optional: fade out effect */
            opacity: 1; /* Start fully visible */
        }
        /* Style for when loading is finished */
        #loadingScreen.fade-out {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">Loading...</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Initialize scene, camera, and renderer
        let scene, camera, renderer;

        // Interactive objects
        let cube, sphere, torus;

        // Mouse/Touch controls
        let controls;

        // --- Loading Manager Setup (Optional for this specific case, but good practice if adding assets later) ---
        // We define it but won't rely on its onLoad for initial startup in *this* version.
        const loadingManager = new THREE.LoadingManager(); 
        
        // Example: If you later add assets, you'd use it like this:
        // const textureLoader = new THREE.TextureLoader(loadingManager);
        // const texture = textureLoader.load('path/to/texture.jpg');
        
        // We can still use onProgress/onError if assets ARE loaded via the manager later.
        const progressBar = document.getElementById('loadingScreen'); // Get reference early
        loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
            progressBar.textContent = 'Loading Asset: ' + Math.round(itemsLoaded / itemsTotal * 100) + '%';
        };
        loadingManager.onError = function (url) {
            console.error('There was an error loading ' + url);
            progressBar.textContent = 'Error loading assets. Check console.';
        };
        // We remove the critical startup logic from onLoad for now.
        loadingManager.onLoad = () => {
           console.log('Loading complete (if any assets were managed)!'); 
           // You could put actions here that *specifically* depend on loaded assets.
        };
        // --- End Loading Manager Setup ---


        function init() {
            console.log("Initializing scene..."); // Debug log
            // Initialize scene FIRST
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.setPixelRatio(window.devicePixelRatio); 
            document.body.appendChild(renderer.domElement);

            // Objects 
            cube = createCube();
            sphere = createSphere();
            torus = createTorus();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x444444); 
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
            directionalLight.position.set(1, 1.5, 1); 
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50; 
            scene.add(directionalLight);

            // Ground plane
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2; 
            plane.position.y = -1.5; 
            plane.receiveShadow = true; 
            scene.add(plane);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; 
            controls.minDistance = 2; 
            controls.maxDistance = 20; 
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 

            // Event Listeners for resize handling
            window.addEventListener('resize', onWindowResize);

            console.log("Initialization complete."); // Debug log
        }


        function createCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.5 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = -2;
            mesh.castShadow = true;
            mesh.receiveShadow = false; 
            scene.add(mesh); 
            mesh.userData = { clickable: true };
            return mesh;
        }

        function createSphere() {
            const geometry = new THREE.SphereGeometry(0.7, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.3, metalness: 0.6 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = 0;
            mesh.castShadow = true;
            mesh.receiveShadow = false; 
            scene.add(mesh); 
            mesh.userData = { clickable: true };
            return mesh;
        }

        function createTorus() {
            const geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100); 
            const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.7, metalness: 0.2 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = 2;
            mesh.castShadow = true;
            mesh.receiveShadow = false; 
            scene.add(mesh); 
            mesh.userData = { clickable: true };
            return mesh;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate); // Request next frame
            
            controls.update(); // Update OrbitControls 

            // Rotate objects for animation
            const delta = 0.01; 
            if (cube) cube.rotation.x += delta;
            if (cube) cube.rotation.y += delta;
            if (sphere) sphere.rotation.y += delta; 
            if (torus) torus.rotation.x -= delta;
            if (torus) torus.rotation.y -= delta * 0.5;

            renderer.render(scene, camera); // Render the scene
        }

        // ---- NEW Startup Function ----
        function hideLoadingScreenAndStart() {
            console.log("Hiding loading screen and starting animation..."); // Debug log
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.classList.add('fade-out'); // Add class to trigger CSS opacity transition

                // Remove the element from the DOM after the transition finishes
                loadingScreen.addEventListener('transitionend', () => {
                    loadingScreen.style.display = 'none'; 
                }, { once: true }); // Use 'once: true' so the listener removes itself

                // Fallback: If transition doesn't fire (e.g., element removed too quickly), 
                // hide it after a delay slightly longer than the transition.
                setTimeout(() => {
                     if (loadingScreen.style.display !== 'none') { // Check if not already hidden by transitionend
                        loadingScreen.style.display = 'none';
                     }
                }, 600); // 500ms transition + 100ms buffer
            } else {
                console.error("Loading screen element not found!");
            }
            
            // Start the animation loop
            animate(); 
        }

        // ---- Execution Start ----
        
        // 1. Initialize the Three.js scene setup
        init(); 

        // 2. Hide the loading screen and start the animation loop
        // We call this directly now, instead of relying on LoadingManager.onLoad
        hideLoadingScreenAndStart(); 

    </script>
</body>
</html>
